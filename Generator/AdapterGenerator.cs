using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace NodeApi.Generator;

// An analyzer bug results in incorrect reports of CA1822 against methods in this class.
#pragma warning disable CA1822 // Mark members as static

/// <summary>
/// Generates adapter methods for C# members exported to JavaScript.
/// </summary>
/// <remarks>
/// Adapter methods are referenced in module registration code generated by
/// <see cref="ModuleGenerator"/>. The adapters provide automatic conversion between `JSValue`
/// and C# types, including both types exported by the current module and common core library types.
/// </remarks>
internal class AdapterGenerator : SourceGenerator
{
    /// <summary>
    /// Prefix for a property getter adapter that converts the returned value to a JSValue.
    /// </summary>
    private const string AdapterGetPrefix = "get_";

    /// <summary>
    /// Prefix for a property setter adapter that converts the value from a JSValue.
    /// </summary>
    private const string AdapterSetPrefix = "set_";

    /// <summary>
    /// Prefix for an adapter thatconverts from a JSCallback to constructor parameters.
    /// </summary>
    private const string AdapterConstructorPrefix = "new_";

    /// <summary>
    /// Prefix for an adapter that converts from a struct or C# array type to a JSValue.
    /// </summary>
    private const string AdapterFromPrefix = "from_";

    /// <summary>
    /// Prefix for an adapter that converts from a JSValue to a struct or C# array type.
    /// </summary>
    private const string AdapterToPrefix = "to_";

    /// <summary>
    /// Prefix for a proxy handler field for a collection type.
    /// </summary>
    private const string ProxyPrefix = "proxy_";

    /// <summary>
    /// Maps from property and method adapter names to property or method symbols.
    /// </summary>
    private readonly Dictionary<string, ISymbol> _adaptedMembers = new();

    /// <summary>
    /// Maps from struct adapter names to struct type symbols.
    /// </summary>
    private readonly Dictionary<string, ITypeSymbol> _adaptedStructs = new();

    /// <summary>
    /// Maps from array adapter names to array element type symbols.
    /// </summary>
    private readonly Dictionary<string, ITypeSymbol> _adaptedArrays = new();

    /// <summary>
    /// Maps from proxy handler names to collection type symbols.
    /// </summary>
    private readonly Dictionary<string, INamedTypeSymbol> _proxiedCollections = new();

    internal AdapterGenerator(GeneratorExecutionContext context)
    {
        Context = context;
    }

    internal static bool HasNoArgsConstructor(ITypeSymbol type)
    {
        return type.GetMembers().OfType<IMethodSymbol>()
            .Any((m) => m.MethodKind == MethodKind.Constructor && m.Parameters.Length == 0);
    }

    /// <summary>
    /// Gets the name of an adapter method to be generated for a constructor, or null
    /// if the constructor does not require an adapter because it takes either no parameters
    /// or a single JSCallbackArgs parameter.
    /// </summary>
    internal string? GetConstructorAdapterName(ITypeSymbol type)
    {
        IMethodSymbol[] constructors = type.GetMembers().OfType<IMethodSymbol>()
            .Where((m) => m.MethodKind == MethodKind.Constructor)
            .ToArray();
        if (!constructors.Any() || constructors.Any((c) => c.Parameters.Length == 0 ||
            (c.Parameters.Length == 1 && c.Parameters[0].Type.Name == "JSCallbackArgs")))
        {
            return null;
        }

        // TODO: Look for [JSExport] attribute among multiple constructors, and/or
        // generate adapter logic to select from among multiple constructors depending on
        // number of arguments?
        if (constructors.Length > 1)
        {
            ReportError(
                DiagnosticId.UnsupportedOverloads,
                constructors.Skip(1).First(),
                "Exported class cannot have an overloaded constructor.");
        }

        IMethodSymbol constructor = constructors.Single();
        string ns = GetNamespace(constructor);
        string className = type.Name;
        string adapterName = $"{AdapterConstructorPrefix}{ns.Replace('.', '_')}_{className}";
        _adaptedMembers.Add(adapterName, constructor);
        return adapterName;
    }

    /// <summary>
    /// Gets the name of an adapter method to be generated for a method, or null
    /// if the method does not require an adapter because it takes either no parameters
    /// or a single JSCallbackArgs parameter and returns either void or JSValue.
    /// </summary>
    internal string? GetMethodAdapterName(IMethodSymbol method)
    {
        // TODO: Check full type names.
        if ((method.Parameters.Length == 0 ||
            (method.Parameters.Length == 1 &&
            method.Parameters[0].Type.Name == "JSCallbackArgs")) &&
            (method.ReturnsVoid ||
            method.ReturnType.Name == "JSValue"))
        {
            return null;
        }

        foreach (IParameterSymbol parameter in method.Parameters)
        {
            if (parameter.RefKind != RefKind.None)
            {
                ReportError(
                    DiagnosticId.UnsupportedMethodParameterType,
                    parameter,
                    "Parameters with 'ref' or 'out' modifiers are not supported in exported methods.");
            }
        }

        string ns = GetNamespace(method);
        string className = method.ContainingType.Name;
        string adapterName = $"{ns.Replace('.', '_')}_{className}_{method.Name}";
        _adaptedMembers.Add(adapterName, method);
        return adapterName;
    }

    /// <summary>
    /// Gets the name of an adapter method to be generated for converting a struct from or
    /// to a JSValue.
    /// </summary>
    private string GetStructAdapterName(ITypeSymbol structType, bool toJS)
    {
        string ns = GetNamespace(structType);
        string structName = structType.Name;
        string prefix = toJS ? AdapterFromPrefix : AdapterToPrefix;
        string adapterName = $"{prefix}{ns.Replace('.', '_')}_{structName}";
        if (!_adaptedStructs.ContainsKey(adapterName))
        {
            _adaptedStructs.Add(adapterName, structType);
        }
        return adapterName;
    }

    /// <summary>
    /// Gets the name of getter and setter adapter methods to be generated for a property.
    /// </summary>
    internal (string?, string?) GetPropertyAdapterNames(IPropertySymbol property)
    {
        // TODO: Check full type name.
        if (property.Type.Name == "JSValue")
        {
            return (null, null);
        }

        string ns = GetNamespace(property);
        string className = property.ContainingType.Name;

        string? getAdapterName = null;
        if (property?.GetMethod?.DeclaredAccessibility == Accessibility.Public)
        {
            getAdapterName = $"{AdapterGetPrefix}{ns.Replace('.', '_')}_{className}_{property.Name}";
            _adaptedMembers.Add(getAdapterName, property);
        }

        string? setAdapterName = null;
        if (property?.SetMethod?.DeclaredAccessibility == Accessibility.Public)
        {
            setAdapterName = $"{AdapterSetPrefix}{ns.Replace('.', '_')}_{className}_{property.Name}";
            _adaptedMembers.Add(setAdapterName, property);
        }

        return (getAdapterName, setAdapterName);
    }

    /// <summary>
    /// Gets the name of an adapter method to be generated for converting an array to/from a
    /// JS array.
    /// </summary>
    private string GetArrayAdapterName(ITypeSymbol elementType, bool toJS)
    {
        string ns = GetNamespace(elementType);
        string elementName = elementType.Name;
        string prefix = toJS ? AdapterFromPrefix : AdapterToPrefix;
        string adapterName = $"{prefix}{ns.Replace('.', '_')}_{elementName}_Array";
        if (!_adaptedArrays.ContainsKey(adapterName))
        {
            _adaptedArrays.Add(adapterName, elementType);
        }
        return adapterName;
    }

    /// <summary>
    /// Gets the name of field to be generated that holds a JS proxy handler for a target type.
    /// </summary>
    private string GetProxyFieldName(INamedTypeSymbol targetType)
    {
        static string GetTypeName(ITypeSymbol type)
        {
            string name = type.Name;
            if (type is INamedTypeSymbol namedType && namedType.TypeParameters.Length > 0)
            {
                name += "_of";
                foreach (ITypeSymbol typeArgument in namedType.TypeArguments)
                {
                    name += "_" + GetTypeName(typeArgument);
                }
            }
            return name;
        }

        string fieldName = ProxyPrefix + GetTypeName(targetType);
        if (!_proxiedCollections.ContainsKey(fieldName))
        {
            _proxiedCollections.Add(fieldName, targetType);
        }
        return fieldName;
    }

    /// <summary>
    /// Generates code for all adapter methods that were requested by a prior call to any of the
    /// Get*AdapterName() methods above.
    /// </summary>
    internal void GenerateAdapters(ref SourceBuilder s)
    {
        foreach (KeyValuePair<string, ISymbol> nameAndSymbol in _adaptedMembers)
        {
            s++;

            string adapterName = nameAndSymbol.Key;
            ISymbol symbol = nameAndSymbol.Value;
            if (symbol is IMethodSymbol method)
            {
                if (method.MethodKind == MethodKind.Constructor)
                {
                    GenerateConstructorAdapter(ref s, adapterName, method);
                }
                else if (GetFullName(method.ReturnType) == "System.Threading.Tasks.Task")
                {
                    GenerateAsyncMethodAdapter(ref s, adapterName, method);
                }
                else
                {
                    GenerateMethodAdapter(ref s, adapterName, method);
                }
            }
            else
            {
                GeneratePropertyAdapter(ref s, adapterName, (IPropertySymbol)symbol);
            }
        }

        foreach (KeyValuePair<string, ITypeSymbol> nameAndSymbol in _adaptedStructs)
        {
            s++;
            string adapterName = nameAndSymbol.Key;
            ITypeSymbol structSymbol = nameAndSymbol.Value;
            GenerateStructAdapter(ref s, adapterName, structSymbol);
        }

        foreach (KeyValuePair<string, ITypeSymbol> nameAndSymbol in _adaptedArrays)
        {
            s++;
            string adapterName = nameAndSymbol.Key;
            ITypeSymbol elementSymbol = nameAndSymbol.Value;
            GenerateArrayAdapter(ref s, adapterName, elementSymbol);
        }

        foreach (KeyValuePair<string, INamedTypeSymbol> nameAndSymbol in _proxiedCollections)
        {
            s++;
            string fieldName = nameAndSymbol.Key;
            INamedTypeSymbol collectionSymbol = nameAndSymbol.Value;
            GenerateProxyField(ref s, fieldName, collectionSymbol);
        }
    }

    private void GenerateConstructorAdapter(
        ref SourceBuilder s,
        string adapterName,
        IMethodSymbol constructor)
    {
        /*
         * private static ConstructorClass new_ConstructorClass(JSCallbackArgs __args)
         * {
         *     var param0Name = (Param0Type)__args[0];
         *     ...
         *     return new ConstructorClass(param1, ...);
         * }
         */

        string ns = GetNamespace(constructor);
        string className = constructor.ContainingType.Name;

        s += $"private static {ns}.{className} {adapterName}(JSCallbackArgs __args)";
        s += "{";

        IReadOnlyList<IParameterSymbol> parameters = constructor.Parameters;
        for (int i = 0; i < parameters.Count; i++)
        {
            AdaptArgument(ref s, parameters[i].Type, parameters[i].Name, i);
        }

        string argumentList = string.Join(", ", parameters.Select((p) => p.Name));

        s += $"return new {ns}.{className}({argumentList});";
        s += "}";
    }

    private void GenerateMethodAdapter(
        ref SourceBuilder s,
        string adapterName,
        IMethodSymbol method)
    {
        /*
         * private static JSValue MethodClass_MethodName(JSCallbackArgs __args)
         * {
         *     if (!(__args.ThisArg.Unwrap() is MethodClass __obj)) return JSValue.Undefined;
         *     var param0Name = (Param0Type)__args[0];
         *     ...
         *     var __result = __obj.MethodName(param0, ...);
         *     return (JSValue)__result;
         * }
         */

        s += $"private static JSValue {adapterName}(JSCallbackArgs __args)";
        s += "{";

        if (!method.IsStatic)
        {
            AdaptThisArg(ref s, method);
        }

        IReadOnlyList<IParameterSymbol> parameters = method.Parameters;
        for (int i = 0; i < parameters.Count; i++)
        {
            AdaptArgument(ref s, parameters[i].Type, parameters[i].Name, i);
        }

        string argumentList = string.Join(", ", parameters.Select((p) => p.Name));
        string returnAssignment = method.ReturnsVoid ? string.Empty : "var __result = ";

        string ns = GetNamespace(method);
        string className = method.ContainingType.Name;

        if (method.IsStatic)
        {
            s += $"{returnAssignment}{ns}.{className}.{method.Name}({argumentList});";
        }
        else
        {
            s += $"{returnAssignment}__obj.{method.Name}({argumentList});";
        }

        if (method.ReturnsVoid)
        {
            s += "return JSValue.Undefined;";
        }
        else
        {
            AdaptReturnValue(ref s, method.ReturnType);
        }

        s += "}";
    }

    private void GenerateAsyncMethodAdapter(
        ref SourceBuilder s,
        string adapterName,
        IMethodSymbol method)
    {
        /*
         * private static JSValue MethodClass_AsyncMethodName(JSCallbackArgs __args)
         * {
         *     if (!(__args.ThisArg.Unwrap() is MethodClass __obj)) return JSValue.Undefined;
         *     var param0Name = (Param0Type)__args[0];
         *     ...
         *     return new JSPromise(async (Action<JSValue> resolve, Action<JSValue> reject) =>
         *     {
         *          var __result = await __obj.AsyncMethodName(param0, ...);
         *          resolve((JSValue)__result);
         *     });
         * }
         */

        s += $"private static JSValue {adapterName}(JSCallbackArgs __args)";
        s += "{";

        if (!method.IsStatic)
        {
            AdaptThisArg(ref s, method);
        }

        IReadOnlyList<IParameterSymbol> parameters = method.Parameters;
        for (int i = 0; i < parameters.Count; i++)
        {
            AdaptArgument(ref s, parameters[i].Type, parameters[i].Name, i);
        }

        s += "return new JSPromise(async (resolve) =>";
        s += "{";

        string argumentList = string.Join(", ", parameters.Select((p) => p.Name));
        string returnAssignment = method.ReturnsVoid ? string.Empty : "var __result = ";

        string ns = GetNamespace(method);
        string className = method.ContainingType.Name;

        if (method.IsStatic)
        {
            s += $"{returnAssignment}await {ns}.{className}.{method.Name}({argumentList});";
        }
        else
        {
            s += $"{returnAssignment}await __obj.{method.Name}({argumentList});";
        }


        if (((INamedTypeSymbol)method.ReturnType).TypeArguments.Length == 0)
        {
            s += "resolve(JSValue.Undefined);";
        }
        else
        {
            ITypeSymbol asyncReturnType = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0];
            s += $"resolve({ConvertFrom("__result", asyncReturnType)});";
        }

        s += "});";
        s += "}";
    }

    private void GeneratePropertyAdapter(
        ref SourceBuilder s,
        string adapterName,
        IPropertySymbol property)
    {
        string ns = GetNamespace(property);
        string className = property.ContainingType.Name;

        if (adapterName.StartsWith(AdapterGetPrefix))
        {
            /*
             * private static JSValue get_PropertyClass_PropertyName(JSCallbackArgs __args)
             * {
             *     if (!(__args.ThisArg.Unwrap() is PropertyClass __obj)) return JSValue.Undefined;
             *     var __result = __obj.PropertyName;
             *     return (JSValue)__result;
             * }
             */

            s += $"private static JSValue {adapterName}(JSCallbackArgs __args)";
            s += "{";

            if (property.IsStatic)
            {
                s += $"var __result = {ns}.{className}.{property.Name};";
            }
            else
            {
                AdaptThisArg(ref s, property);
                s += $"var __result = __obj.{property.Name};";
            }

            AdaptReturnValue(ref s, property.Type);
            s += "}";
        }
        else
        {
            /*
             * private static JSValue set_PropertyClass_PropertyName(JSCallbackArgs __args)
             * {
             *     if (!(__args.ThisArg.Unwrap() is PropertyClass __obj)) return JSValue.Undefined;
             *     var __value = (PropertyType)__args[0];
             *     __obj.PropertyName = __value;
             *     return JSValue.Undefined;
             * }
             */

            s += $"private static JSValue {adapterName}(JSCallbackArgs __args)";
            s += "{";

            if (property.IsStatic)
            {
                AdaptArgument(ref s, property.Type, "__value", 0);
                s += $"{ns}.{className}.{property.Name} = __value;";
            }
            else
            {
                AdaptThisArg(ref s, property);
                AdaptArgument(ref s, property.Type, "__value", 0);
                s += $"__obj.{property.Name} = __value;";
            }

            s += "return JSValue.Undefined;";
            s += "}";
        }
    }

    private void GenerateStructAdapter(
        ref SourceBuilder s,
        string adapterName,
        ITypeSymbol structType)
    {
        List<ISymbol> copyableProperties = new();
        foreach (ISymbol member in structType.GetMembers()
            .Where((m) => !m.IsStatic && m.DeclaredAccessibility == Accessibility.Public))
        {
            if (member.Kind == SymbolKind.Property &&
                ((IPropertySymbol)member).GetMethod?.DeclaredAccessibility == Accessibility.Public &&
                ((IPropertySymbol)member).SetMethod?.DeclaredAccessibility == Accessibility.Public)
            {
                copyableProperties.Add(member);
            }
            else if (member.Kind == SymbolKind.Field &&
                !((IFieldSymbol)member).IsConst &&
                !((IFieldSymbol)member).IsReadOnly)
            {
                copyableProperties.Add(member);
            }
        }

        string ns = GetNamespace(structType);
        string structName = structType.Name;

        if (adapterName.StartsWith(AdapterFromPrefix))
        {
            /*
             * private static JSValue from_StructName(StructName value)
             * {
             *     JSValue jsValue = JSContext.Current.CreateStruct<StructName>();
             *     jsValue["property0"] = (JSValue)value.Property0;
             *     ...
             *     return jsValue;
             * }
             */

            s += $"private static JSValue {adapterName}({ns}.{structName} value)";
            s += "{";
            s += $"JSValue jsValue = JSContext.Current.CreateStruct<{ns}.{structName}>();";

            foreach (ISymbol property in copyableProperties)
            {
                ITypeSymbol propertyType = (property as IPropertySymbol)?.Type ??
                    ((IFieldSymbol)property).Type;
                s += $"jsValue[\"{ToCamelCase(property.Name)}\"] = " +
                    $"{ConvertFrom($"value.{property.Name}", propertyType)};";
            }

            s += "return jsValue;";
            s += "}";
        }
        else
        {
            /*
             * private static StructName to_StructName(JSValue jsValue)
             * {
             *     StructName value = new();
             *     value.Property0 = (Property0Type)jsValue["property0"];
             *     ...
             *     return jsValue;
             * }
             */

            s += $"private static {ns}.{structName} {adapterName}(JSValue jsValue)";
            s += "{";
            s += $"{ns}.{structName} value = new();";

            foreach (ISymbol property in copyableProperties)
            {
                ITypeSymbol propertyType = (property as IPropertySymbol)?.Type ??
                    ((IFieldSymbol)property).Type;
                s += $"value.{property.Name} = " +
                    $"{ConvertTo($"jsValue[\"{ToCamelCase(property.Name)}\"]", propertyType)};";
            }

            s += "return value;";
            s += "}";
        }
    }

    private void GenerateArrayAdapter(
        ref SourceBuilder s,
        string adapterName,
        ITypeSymbol elementType)
    {
        string ns = GetNamespace(elementType);
        string elementName = elementType.Name;

        if (adapterName.StartsWith(AdapterFromPrefix))
        {
            /*
             * private static JSValue from_ElementType_Array(ElementType[] array)
             * {
             *     JSArray jsArray = new JSArray(array.Length);
             *     for (int i = 0; i < array.Length; i++)
             *     {
             *         jsArray[i] = (JSValue)array[i];
             *     }
             *     return jsArray;
             * }
             */

            s += $"private static JSValue {adapterName}({ns}.{elementName}[] array)";
            s += "{";
            s += "JSArray jsArray = new JSArray(array.Length);";
            s += "for (int i = 0; i < array.Length; i++)";
            s += "{";
            s += $"jsArray[i] = {ConvertFrom("array[i]", elementType)};";
            s += "}";
            s += "return jsArray;";
            s += "}";
        }
        else
        {
            /*
             * private static ElementType[] to_ElementType_Array(JSValue value)
             * {
             *     JSArray jsArray = (JSArray)value;
             *     ElementType[] array = new ElementType[jsArray.Length];
             *     for (int i = 0; i < array.Length; i++)
             *     {
             *         array[i] = (ElementType)jsArray[i];
             *     }
             *     return array;
             * }
             */

            s += $"private static {ns}.{elementName}[] {adapterName}(JSValue value)";
            s += "{";
            s += "JSArray jsArray = (JSArray)value;";
            s += $"{ns}.{elementName}[] array = new {ns}.{elementName}[jsArray.Length];";
            s += "for (int i = 0; i < array.Length; i++)";
            s += "{";
            s += $"array[i] = {ConvertTo("jsArray[i]", elementType)};";
            s += "}";
            s += "return array;";
            s += "}";
        }
    }

    private void GenerateProxyField(
        ref SourceBuilder s,
        string fieldName,
        INamedTypeSymbol targetType)
    {
        /**
         * private static readonly Lazy<JSProxy.Handler> proxy_ICollection_of_Int32 = new(
         *     () => JSIterable.CreateProxyHandlerForCollection<int>(JSContext.Current, (item) => (JSValue)(item)),
         *     LazyThreadSafetyMode.ExecutionAndPublication);
         */

        s += $"private static readonly System.Lazy<JSProxy.Handler> {fieldName} = new(";

        ITypeSymbol elementType = targetType.TypeArguments[0];
        ITypeSymbol keyType = targetType.TypeArguments[0];
        ITypeSymbol? valueType = targetType.TypeArguments.Length > 1 ? targetType.TypeArguments[1] : null;
        s += targetType.OriginalDefinition.Name switch
        {
            "IEnumerable" =>
                $"() => JSIterable.CreateProxyHandlerForEnumerable<{elementType}>(" +
                "\nJSContext.Current, " +
                $"\n(item) => {ConvertFrom("item", elementType)}),",
            "IReadOnlyCollection" =>
                $"() => JSIterable.CreateProxyHandlerForReadOnlyCollection<{elementType}>(" +
                "\nJSContext.Current, " +
                $"\n(item) => {ConvertFrom("item", elementType)}),",
            "ICollection" =>
                $"() => JSIterable.CreateProxyHandlerForCollection<{elementType}>(" +
                "\nJSContext.Current, " +
                $"\n(item) => {ConvertFrom("item", elementType)}, " +
                $"\n(value) => {ConvertTo("value", elementType)}),",
            "IReadOnlyList" =>
                $"() => JSArray.CreateProxyHandlerForReadOnlyList<{elementType}>(" +
                "\nJSContext.Current, " +
                $"\n(item) => {ConvertFrom("item", elementType)}),",
            "IList" =>
                $"() => JSArray.CreateProxyHandlerForList<{elementType}>(" +
                "\nJSContext.Current, " +
                $"\n(item) => {ConvertFrom("item", elementType)}, " +
                $"\n(value) => {ConvertTo("value", elementType)}),",
            "IReadOnlySet" =>
                $"() => JSSet.CreateProxyHandlerForReadOnlySet<{elementType}>(" +
                "\nJSContext.Current, " +
                $"\n(item) => {ConvertFrom("item", elementType)}, " +
                $"\n(value) => {ConvertTo("value", elementType)}),",
            "ISet" =>
                $"() => JSSet.CreateProxyHandlerForSet<{elementType}>(" +
                "\nJSContext.Current, " +
                $"\n(item) => {ConvertFrom("item", elementType)}, " +
                $"\n(value) => {ConvertTo("value", elementType)}),",
            "IReadOnlyDictionary" =>
                $"() => JSMap.CreateProxyHandlerForReadOnlyDictionary<{keyType}, {valueType!}>(" +
                "\nJSContext.Current, " +
                $"\n(key) => {ConvertFrom("key", keyType)}, " +
                $"\n(value) => {ConvertFrom("value", valueType!)}, " +
                $"\n(key) => {ConvertTo("key", keyType)}),",
            "IDictionary" =>
                $"() => JSMap.CreateProxyHandlerForDictionary<{keyType}, {valueType!}>(" +
                "\nJSContext.Current, " +
                $"\n(key) => {ConvertFrom("key", keyType)}, " +
                $"\n(value) => {ConvertFrom("value", valueType!)}, " +
                $"\n(key) => {ConvertTo("key", keyType)}, " +
                $"\n(value) => {ConvertTo("value", valueType!)}),",
            _ => throw new NotSupportedException("Unsupported proxy target type: " + targetType),
        };

        s += "\tSystem.Threading.LazyThreadSafetyMode.ExecutionAndPublication);";
    }

    /// <summary>
    /// Checks whether an element type is one of the JS TypedArray element types.
    /// </summary>
    private bool IsTypedArrayType(ITypeSymbol elementType)
    {
        return elementType.SpecialType switch
        {
            SpecialType.System_SByte => true,
            SpecialType.System_Byte => true,
            SpecialType.System_Int16 => true,
            SpecialType.System_UInt16 => true,
            SpecialType.System_Int32 => true,
            SpecialType.System_UInt32 => true,
            SpecialType.System_Int64 => true,
            SpecialType.System_UInt64 => true,
            SpecialType.System_Single => true,
            SpecialType.System_Double => true,
            _ => false,
        };
    }

    /// <summary>
    /// Generates code to get the `this` object for a class or struct instance method or
    /// instance property getter/setter.
    /// </summary>
    private void AdaptThisArg(ref SourceBuilder s, ISymbol symbol)
    {
        string ns = GetNamespace(symbol);
        string typeName = symbol.ContainingType.Name;

        if (symbol.ContainingType.GetAttributes().Any(
            (a) => a.AttributeClass?.Name == "JSModuleAttribute"))
        {
            // For a method on a module class, the .NET object is stored in module instance data.
            // Note `ThisArg` is ignored for module-level methods.
            s += $"if (!(JSContext.Current.Module is {ns}.{typeName} __obj)) " +
                "return JSValue.Undefined;";
        }
        else if (symbol.ContainingType.TypeKind == TypeKind.Class)
        {
            // For normal instance methods, the .NET object is wrapped by the JS object.
            s += $"if (!(__args.ThisArg.Unwrap() is {ns}.{typeName} __obj)) " +
                "return JSValue.Undefined;";
        }
        else if (symbol.ContainingType.TypeKind == TypeKind.Struct)
        {
            // Structs are not wrapped; they are passed by value via an adapter method.
            string adapterName = GetStructAdapterName(symbol.ContainingType, toJS: false);
            s += $"{ns}.{typeName} __obj = {adapterName}(__args.ThisArg);";
        }
    }

    /// <summary>
    /// Generates code to convert a JS argument to the expected parameter name and type for a
    /// constructor, method, or property setter.
    /// </summary>
    private void AdaptArgument(
        ref SourceBuilder s,
        ITypeSymbol parameterType,
        string parameterName,
        int index)
    {
        s += $"var {parameterName} = {ConvertTo($"__args[{index}]", parameterType)};";
    }

    /// <summary>
    /// Generates code to convert a return value to a JSValue result for a method or property getter.
    /// </summary>
    private void AdaptReturnValue(ref SourceBuilder s, ITypeSymbol returnType)
    {
        s += $"return {ConvertFrom("__result", returnType)};";
    }

    /// <summary>
    /// Generates code to wrap an expression to convert it to a C# type from a JSValue.
    /// </summary>
    /// <param name="fromExpression">Expression that evaluates to a JSValue.</param>
    /// <param name="toType">Type of the resulting expression.</param>
    /// <returns>Generated expression of the specified C# type.</returns>
    /// <remarks>
    /// While primitive types can be converted with a simple cast (as represented in many example
    /// comments in this file), other types require more complex conversion expressions, possibly
    /// including recursive calls to further conversions or adapter methods.
    /// </remarks>
    private string ConvertTo(string fromExpression, ITypeSymbol toType)
    {
        (toType, bool isNullable) = SplitNullable(toType);
        if (isNullable)
        {
            return $"({fromExpression}).IsNullOrUndefined() " +
                $"?\n({toType}?)null :\n{ConvertTo(fromExpression, toType)}";
        }

        if (CanCast(toType!))
        {
            return $"({toType})({fromExpression})";
        }
        else if (toType.TypeKind == TypeKind.Enum)
        {
            return $"({toType})({((INamedTypeSymbol)toType).EnumUnderlyingType})({fromExpression})";
        }
        else if (toType.TypeKind == TypeKind.Class)
        {
            VerifyReferencedTypeIsExported(toType);

            return $"({toType})JSNativeApi.Unwrap({fromExpression})";

        }
        else if (toType.TypeKind == TypeKind.Struct)
        {
            if (toType is INamedTypeSymbol namedType &&
                namedType.TypeParameters.Length == 1 &&
                namedType.OriginalDefinition.Name == "Memory" &&
                IsTypedArrayType(namedType.TypeArguments[0]))
            {
                // For supported Memory<T> element types, assume the JS value is a typed-array.
                return $"((JSTypedArray<{namedType.TypeArguments[0]}>){fromExpression}).AsMemory()";
            }

            VerifyReferencedTypeIsExported(toType);

            string adapterName = GetStructAdapterName(toType, toJS: false);
            return $"{adapterName}({fromExpression})";
        }
        else if (toType.TypeKind == TypeKind.Array)
        {
            ITypeSymbol elementType = ((IArrayTypeSymbol)toType).ElementType;
            VerifyReferencedTypeIsExported(elementType);

            string adapterName = GetArrayAdapterName(elementType, toJS: false);
            return $"{adapterName}({fromExpression})";
        }
        else if (toType is INamedTypeSymbol namedType && namedType.TypeParameters.Length > 0)
        {
            string collectionTypeName = toType.OriginalDefinition.Name;
            if (collectionTypeName == "IList" ||
                collectionTypeName == "ISet" ||
                collectionTypeName == "IReadOnlySet" ||
                collectionTypeName == "ICollection")
            {
                // A collection passed from JS to C# may be either a previously wrapped/proxied
                // C# collection object or a regular JS array that needs to be adapted to the
                // C# collection interface.
                // Read-write collections require bi-directional element conversion lamdas.
                string jsTypeName = collectionTypeName.EndsWith("Set") ? "Set" : "Array";
                ITypeSymbol elementType = namedType.TypeArguments[0];
                return $"(JSNativeApi.TryUnwrap({fromExpression}, out var __collection) " +
                    $"?\n({toType})__collection! :\n((JS{jsTypeName}){fromExpression})" +
                    $".As{collectionTypeName.Substring(1)}<{elementType}>(" +
                    $"\n(value) => {ConvertTo("value", elementType)}, " +
                    $"\n(value) => {ConvertFrom("value", elementType)}))";
            }
            else if (collectionTypeName == "IReadOnlyList" ||
                collectionTypeName == "IReadOnlyCollection" ||
                collectionTypeName == "IEnumerable")
            {
                // Some collections only require an element conversion lamda in one direction.
                string jsTypeName = collectionTypeName.EndsWith("Enumerable") ? "Iterable" : "Array";
                ITypeSymbol elementType = namedType.TypeArguments[0];
                return $"(JSNativeApi.TryUnwrap({fromExpression}, out var __collection) " +
                    $"?\n({toType})__collection! :\n((JS{jsTypeName}){fromExpression})" +
                    $".As{collectionTypeName.Substring(1)}<{elementType}>(" +
                    $"\n(value) => {ConvertTo("value", elementType)}))";
            }
            else if (collectionTypeName == "IDictionary")
            {
                ITypeSymbol keyType = namedType.TypeArguments[0];
                ITypeSymbol valueType = namedType.TypeArguments[1];
                return $"(JSNativeApi.TryUnwrap({fromExpression}, out var __collection) " +
                    $"?\n({toType})__collection! :\n((JSMap){fromExpression})" +
                    $".AsDictionary<{keyType}, {valueType}>(" +
                    $"\n(key) => {ConvertTo("key", keyType)}, " +
                    $"\n(value) => {ConvertTo("value", valueType)}," +
                    $"\n(key) => {ConvertFrom("key", keyType)}, " +
                    $"\n(value) => {ConvertFrom("value", valueType)}))";
            }
            else if (collectionTypeName == "IReadOnlyDictionary")
            {
                ITypeSymbol keyType = namedType.TypeArguments[0];
                ITypeSymbol valueType = namedType.TypeArguments[1];
                return $"(JSNativeApi.TryUnwrap({fromExpression}, out var __collection) " +
                    $"?\n({toType})__collection! :\n((JSMap){fromExpression})" +
                    $".AsReadOnlyDictionary<{keyType}, {valueType}>(" +
                    $"\n(key) => {ConvertTo("key", keyType)}, " +
                    $"\n(value) => {ConvertTo("value", valueType)}," +
                    $"\n(key) => {ConvertFrom("key", keyType)}))";
            }
        }

        // TODO: Handle other kinds of conversions from JSValue.
        // TODO: Handle unwrapping external values.
        return $"default({toType})" + (toType.IsValueType ? string.Empty : "!");
    }

    /// <summary>
    /// Generates code to wrap an expression to convert it from a C# type to a JSValue.
    /// </summary>
    /// <param name="fromExpression">Expression that evaluates to a C# type.</param>
    /// <param name="fromType">Type of the original expression.</param>
    /// <returns>Generated expression of type JSValue.</returns>
    /// <remarks>
    /// While primitive types can be converted with a simple cast (as represented in many example
    /// comments in this file), other types require more complex conversion expressions, possibly
    /// including recursive calls to further conversions or adapter methods.
    /// </remarks>
    private string ConvertFrom(string fromExpression, ITypeSymbol fromType)
    {
        (fromType, bool isNullable) = SplitNullable(fromType);
        if (isNullable)
        {
            // TODO: Re-evaluate whether C# nulls should be converted to JS null or undefined.
            if (fromType.IsValueType)
            {
                return $"{fromExpression}.HasValue ? " +
                    $"{ConvertFrom($"({fromExpression}).Value", fromType)} : JSValue.Null";
            }
            else
            {
                return $"{fromExpression} == null ? " +
                    $"JSValue.Null : {ConvertFrom($"{fromExpression}", fromType)}";
            }
        }

        if (CanCast(fromType!))
        {
            return $"(JSValue)({fromExpression})";
        }
        else if (fromType.TypeKind == TypeKind.Enum)
        {
            return $"(JSValue)({((INamedTypeSymbol)fromType).EnumUnderlyingType})({fromExpression})";
        }
        else if (fromType.TypeKind == TypeKind.Class)
        {
            VerifyReferencedTypeIsExported(fromType);
            return $"JSContext.Current.GetOrCreateObjectWrapper({fromExpression})";
        }
        else if (fromType.TypeKind == TypeKind.Struct)
        {
            if (fromType is INamedTypeSymbol namedType &&
                namedType.TypeParameters.Length == 1 &&
                namedType.OriginalDefinition.Name == "Memory" &&
                IsTypedArrayType(namedType.TypeArguments[0]))
            {
                // For supported element types, wrap Memory<T> in a JSTypedArray.
                return $"new JSTypedArray<{namedType.TypeArguments[0]}>({fromExpression})";
            }

            VerifyReferencedTypeIsExported(fromType);

            string adapterName = GetStructAdapterName(fromType, toJS: true);
            return $"{adapterName}({fromExpression})";
        }
        else if (fromType.TypeKind == TypeKind.Array)
        {
            ITypeSymbol elementType = ((IArrayTypeSymbol)fromType).ElementType;
            VerifyReferencedTypeIsExported(elementType);

            string adapterName = GetArrayAdapterName(elementType, toJS: true);
            return $"{adapterName}({fromExpression})";
        }
        else if (fromType is INamedTypeSymbol namedType && namedType.TypeParameters.Length > 0)
        {
            string collectionTypeName = fromType.OriginalDefinition.Name;
            if (collectionTypeName == "IList" ||
                collectionTypeName == "IReadOnlyList" ||
                collectionTypeName == "ISet" ||
                collectionTypeName == "IReadOnlySet" ||
                collectionTypeName == "IDictionary" ||
                collectionTypeName == "IReadOnlyDictionary" ||
                collectionTypeName == "ICollection" ||
                collectionTypeName == "IReadOnlyCollection" ||
                collectionTypeName == "IEnumerable")
            {
                // Collections are wrapped with a JS proxy object to avoid copying the data.
                // When the same collection is passed multiple times, the proxy object is re-used.
                // Read-write collections require bi-directional element conversion lamdas.
                return $"JSContext.Current.GetOrCreateCollectionWrapper({fromExpression}, " +
                    $"{GetProxyFieldName(namedType)}!.Value)";
            }
        }

        // TODO: Handle other kinds of conversions to JSValue.
        // TODO: Consider wrapping unsupported types in a value of type "external".
        return "JSValue.Undefined";
    }

    /// <summary>
    /// Throws an exception unless a referenced type has either a built-in conversion or is
    /// exported by this module and therefore has generated adapters.
    /// </summary>
    private void VerifyReferencedTypeIsExported(ITypeSymbol type)
    {
        if (CanCast(type))
        {
            return;
        }

        // Collection types have special support in the ConvertFrom()/ConvertTo() methods above.
        switch (type.SpecialType)
        {
            case SpecialType.System_Array:
            case SpecialType.System_Collections_Generic_IEnumerable_T:
            case SpecialType.System_Collections_Generic_IReadOnlyCollection_T:
            case SpecialType.System_Collections_Generic_ICollection_T:
            case SpecialType.System_Collections_Generic_IReadOnlyList_T:
            case SpecialType.System_Collections_Generic_IList_T:
                return;
            default: break;
        }

        // Memory<T> doesn't have a SpecialType enumeration.
        // Conversion methods above handle it specially, but only for typed-array element types.
        if (type is INamedTypeSymbol namedType &&
            namedType.TypeParameters.Length == 1 &&
            namedType.OriginalDefinition.Name == "Memory" &&
            IsTypedArrayType(namedType.TypeArguments[0]))
        {
            return;
        }

        if (ModuleGenerator.GetJSExportAttribute(type) == null)
        {
            // TODO: Consider an option to automatically export referenced classes?
            ReportError(
                DiagnosticId.ReferenedTypeNotExported,
                type,
                $"Referenced type {type} is not exported.");
        }
    }

    /// <summary>
    /// Checks if a type is a primitive type for which JSValue provides direct cast conversions.
    /// </summary>
    private static bool CanCast(ITypeSymbol type)
    {
        (type, bool isNullable) = SplitNullable(type);
        return type.SpecialType switch
        {
            SpecialType.System_Boolean => true,
            SpecialType.System_SByte => true,
            SpecialType.System_Byte => true,
            SpecialType.System_Int16 => true,
            SpecialType.System_UInt16 => true,
            SpecialType.System_Int32 => true,
            SpecialType.System_UInt32 => true,
            SpecialType.System_Int64 => true,
            SpecialType.System_UInt64 => true,
            SpecialType.System_Single => true,
            SpecialType.System_Double => true,
            SpecialType.System_String => !isNullable,
            _ => false,
        };
    }

    /// <summary>
    /// Detects Nullable<T> value types or reference type with nullable annotations, and returns
    /// the non-nullable type and a boolean indicating whether it was nullable.
    /// </summary>
    private static (ITypeSymbol, bool) SplitNullable(ITypeSymbol type)
    {
        bool isNullable = false;
        if (type.NullableAnnotation == NullableAnnotation.Annotated)
        {
            isNullable = true;

            // Handle either a Nullable<T> (value type) or a nullable reference type.
            type = type.IsValueType
                ? ((INamedTypeSymbol)type).TypeArguments[0]
                : type.OriginalDefinition;
        }
        return (type, isNullable);
    }
}
