# TypeScript type definitions for .NET APIs

## Building type definitions
At the moment, a `.d.ts` file is generated by the C# source generator at the same time it generates `[JSExport]` marshaling code. That is not appropriate for a C# source generator, and anyway it doesn't support generating type definitions for pre-built assemblies. So this functionality will move to a separate tool soon, along with MSBuild integration support.

## Type projections reference

### Primitive types
| C# Type  | TypeScript Projection |
|----------|-----------------------|
| `bool`   | `boolean`             |
| `sbyte`  | `number`              |
| `byte`   | `number`              |
| `short`  | `number`              |
| `ushort` | `number`              |
| `int`    | `number`              |
| `uint`   | `number`              |
| `long`   | `number`              |
| `ulong`  | `number`              |
| `nint`   | `number`              |
| `nuint`  | `number`              |
| `float`  | `number`              |
| `double` | `number`              |
| `string` | `string`              |

### Object types

| C# Type                     | TypeScript Projection       |
|-----------------------------|-----------------------------|
| `class Example`             | `class Example`             |
| `struct Example`            | `class Example`             |
| `interface IExample`        | `interface IExample`        |
| `delegate A Example(B)`     | `example: (B) => A`         |
| `enum Example { None = 0 }` | `enum Example { None = 0 }` |

### Array types
| C# Type     | TypeScript Projection |
|-------------|-----------------------|
| `sbyte[]`   | `Int8Array`           |
| `sbyte[]`   | `UInt8Array`          |
| `short[]`   | `Int16Array`          |
| `ushort[]`  | `UInt16Array`         |
| `int[]`     | `Int32Array`          |
| `uint[]`    | `UInt32Array`         |
| `long[]`    | `BigInt64Array`       |
| `ulong[]`   | `BigUInt64Array`      |
| `float[]`   | `Float32Array`        |
| `double[]`  | `Float64Array`        |
| other `T[]` | `T[]` (`Array<T>`)    |

Typed arrays exported from C# use shared memory to avoid copying. Regular arrays (for which no JS "typed" arrays exist) are copied across the C#/JS boundary, therefore using collection interfaces such as `IList<T>` may be more efficient for larger arrays.

### Collection types

| C# Type                  | TypeScript Projection |
|--------------------------|-----------------------|
| `IEnumerable<T>`         | `Iterable<T>`         |
| `IReadOnlyCollection<T>` | `ReadonlySet<T>`      |
| `ICollection<T>`         | `Set<T>`              |
| `IReadOnlySet<T>`        | `ReadonlySet<T>`      |
| `ISet<T>`                | `Set<T>`              |
| `IReadOnlyList<T>`       | `readonly T[]` (`ReadonlyArray<T>`) |
| `IList<T>`               | `T[]` (`Array<T>`)    |
| `IReadOnlyDictionary<T>` | `ReadonlyMap<T>`      |
| `IDictionary<T>`         | `Map<T>`              |

Collections exported from C# use JavaScript proxies with C# handlers to avoid copying items across the C#/JS boundary. But this implementation detail does not affect the types visible to JavaScript code, e.g. a dictionary from C# still satisfies `instanceof Map` in JS.

### Special types

| C# Type            | TypeScript Projection |
|--------------------|-----------------------|
| `Task`             | `Promise<void>`       |
| `Task<T>`          | `Promise<T>`          |
| `DateTime`         | `Date`                |
| `DateTimeOffset`   | `[Date, number]`      |
| `TimeSpan`         | `number`              |
| `BigInteger`       | `BigInt`              |
| `Tuple<A, B, ...>` | `[A, B, ...]`         |

Dates marshalled from JavaScript will always be `Utc` kind. A `TimeSpan` is projected to JavaScript as a decimal number of milliseconds. A `DateTimeOffset` is projected as a tuple of the UTC date-time and the offset in (positive or negative) milliseconds.
